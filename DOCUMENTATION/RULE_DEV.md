# Правила разработки для проекта "Zone of Shadows"

## 1. Общие принципы разработки
- **Модульность**: Код должен быть разделён на логические модули (компоненты, классы, сервисы) с чёткими зонами ответственности. Например, разделение клиентской части (`src/game`, `src/components`) и серверной (`server/pointRoom.js`, `server/admin.js`) уже реализовано и должно поддерживаться.
- **Атомарность (принцип единой ответственности)**: Каждый модуль, функция или класс должен выполнять только одну задачу. Например, PlayerController.js отвечает только за управление позицией игрока, а ConnectionManager.js — за подключение к комнатам Colyseus. Избегайте смешивания логики (например, обработки данных и UI в одном компоненте).
- **Читаемость**: Используйте понятные имена переменных, функций и классов, отражающие их назначение (например, `PlayerController`, `ConnectionManager`).
- **Документация**: Каждый модуль должен сопровождаться краткими комментариями о его назначении и ключевых методах. Используйте JSDoc для документирования функций (пример: папка `docs/`).
- **Стабильность**: Перед внедрением нового функционала тестируйте его в изолированной среде (локально или на staging).
- **Повторное использование кода (DRY)**: Избегайте дублирования логики. Выносите повторяющиеся участки в утилиты или общие модули (например, utils/config.js для конфигурации).
- **Разделение слоёв**: Поддерживайте разделение логики на слои: представление (React, Phaser), бизнес-логика (классы, хуки), взаимодействие с сервером (Colyseus, Supabase). Например, PhaserGame.jsx отвечает только за рендеринг, а GameStateManager.js — за состояние игры.
- **Обработка ошибок**: Все функции, взаимодействующие с внешними сервисами (Supabase, Redis, NATS), должны предусматривать обработку ошибок и логирование (например, через logger.js).
- **Тестируемость**: Пишите код так, чтобы его было легко тестировать. Избегайте жёстких зависимостей, используйте инъекцию зависимостей где возможно (например, передавайте scene в PlayerController через конструктор).
- **Гибкость и расширяемость**: Проектируйте код с учётом будущих изменений. Например, система навыков персонажа должна легко поддерживать добавление новых типов навыков без рефакторинга ядра.
- **Производительность**: Оптимизируйте код только при необходимости. Избегайте преждевременной оптимизации, но учитывайте возможные узкие места (например, запросы к базе данных). Например, используйте ленивую загрузку ресурсов Phaser или кэширование данных в Redis для часто запрашиваемых операций.
- **Безопасность**: Поддерживайте безопасность приложения на всех уровнях: аутентификация (Supabase Auth), авторизация (роли пользователей), защита от инъекций (SQL, XSS), обработка конфиденциальных данных (персональные данные, пароли). Проверяйте и валидируйте все входные данные, особенно на серверной части (например, в pointRoom.js при обработке токенов). Избегайте прямого доступа к глобальным объектам или чувствительным данным.
- **Консистентность**: Придерживайтесь единого стиля кода (форматирование, имена, структура) во всём проекте. Например, используйте camelCase для функций и переменных, как в loadConfig, и kebab-case для файлов конфигурации, как в docker-compose.yml.
- **Иммутабельность**: По возможности избегайте изменения состояния напрямую. Используйте копирование объектов и массивов (например, с помощью spread-оператора ...) для предсказуемого поведения, особенно в состоянии React или Colyseus.
- **Логирование и мониторинг**: Встраивайте точки логирования в ключевые места (например, подключение к комнате, ошибки аутентификации) и используйте метрики (Prometheus) для отслеживания поведения системы.
- **Интернационализация (i18n)**: Проектируйте код с возможностью добавления поддержки нескольких языков. Например, выносите текстовые строки (UI, сообщения) в отдельные файлы или константы, а не вшивайте их напрямую в код.
- **Асинхронность**: Используйте асинхронные паттерны (async/await, промисы) для операций с сетью или длительных вычислений, избегая блокирующего кода. Например, подключение к комнате в ConnectionManager.js должно быть асинхронным.

## 2. Правила коммитов
Коммиты должны быть атомарными, логически завершёнными и следовать единому стилю. Используйте следующие правила для оформления коммитов в проекте "Zone of Shadows".

### 2.1. Структура коммита
```
<тип>(<область>): <краткое описание>
<пустая строка>
<подробное описание (опционально)>
```

- **Тип**: Указывает категорию изменений:
  - `feat` — добавление новой функциональности (например, новая механика торговли или навык персонажа).
  - `fix` — исправление ошибки (например, баг с перемещением по гексам).
  - `docs` — изменения в документации (обновление README или JSDoc).
  - `style` — изменения форматирования кода (без изменения логики).
  - `refactor` — рефакторинг кода (оптимизация без добавления фич).
  - `test` — добавление или изменение тестов.
  - `chore` — мелкие задачи (обновление зависимостей, настройка CI/CD).
  - `perf` — улучшение производительности (например, оптимизация загрузки ресурсов Phaser).

- **Область**: Контекст изменений, соответствует структуре проекта:
  - `client` — клиентская часть (React, Phaser, UI).
  - `server` — серверная часть (Node.js, Colyseus, Express).
  - `game` — игровая логика (сцены Phaser, механики).
  - `auth` — аутентификация (Supabase Auth).
  - `db` — база данных (Supabase, миграции).
  - `infra` — инфраструктура (Docker, Nginx, CI/CD).

- **Краткое описание**: Однострочное описание (до 50 символов), начинающееся с глагола в повелительном наклонении (например, "Добавить", "Исправить").
- **Подробное описание**: Опционально, если требуется объяснить контекст или детали (до 72 символов в строке).
-
### 2.2. Примеры коммитов
```
feat(game): Добавить систему бартера между игроками

Реализован механизм торговли через запросы и внутренний чат.
Используется Colyseus для синхронизации состояния.
```
```
fix(client): Исправить баг с отображением гексагональной сетки

Phaser.js теперь корректно рендерит HexGrid при масштабировании.
```
```
docs(server): Обновить README с описанием pointRoom.js

Добавлено описание логики синхронизации игроков в комнате.
```
```
refactor(auth): Упростить логику useAuth хука

Убрано дублирование setUser, теперь только onAuthStateChange.
```

### 2.3. Правила оформления
- Пишите коммиты на русском языке для единообразия (учитывая русскоязычную документацию проекта).
- Избегайте общих фраз ("фикс", "добавлено что-то") — указывайте конкретные изменения.
- Один коммит = одна логическая единица. Не смешивайте исправление багов и новый функционал.

## 3. Работа с ветками
- **main**: Основная ветка для продакшна, содержит стабильную версию.
- **stage**: Ветка для тестирования перед релизом.
- **develop**: Ветка для разработки новых фич и исправлений.
- **feature/<название>**: Ветки для новых фич (например, `feature/trade-system`).
- **fix/<название>**: Ветки для исправления багов (например, `fix/hex-grid-render`).
- **Именование**: Используйте kebab-case, коротко и по делу.
- **Слияние**: Используйте Pull Requests с ревью для интеграции в `stage` или `main`.

## 4. Тестирование
- **Юнит-тесты**: Используйте Jest для проверки отдельных модулей (например, `CommandSender.js`, `redisService.js`).
- **E2E-тесты**: Внедрите Cypress для проверки игровых сценариев (например, подключение к комнате Colyseus).
- **Ручное тестирование**: Перед слиянием в `stage` проверяйте ключевые механики (перемещение, бой, торговля) в локальной среде.

## 5. Деплой и CI/CD
- **Автоматизация**: Используйте GitHub Actions для сборки и деплоя (как в `deploy.yml`).
- **Окружения**: Поддерживайте разделение dev/stage/prod с соответствующими `docker-compose.yml`.
- **Проверка**: Каждый PR должен проходить линтинг (`npm run lint`) и тесты (`npm test`).

## 6. Кодстайл
- **Линтинг**: Используйте ESLint с конфигурацией из `.eslintrc.cjs` для единообразия.
- **Форматирование**: Применяйте Prettier через `npm run format` перед коммитом.
- **Имена файлов**: Используйте camelCase для JS-файлов (как в `PlayerController.js`) и kebab-case для конфигураций (как в `docker-compose.dev.yml`).

---

# Правила документирования с использованием JSDoc для проекта "Zone of Shadows"

## 1. Общие принципы
- **Обязательность**: Каждая функция, класс, метод, модуль, константа или переменная, доступная за пределами модуля (экспортируемая), должна быть задокументирована с использованием JSDoc.
- **Ясность**: Описание должно быть кратким, но содержательным, объясняя назначение, входные данные и результат.
- **Единообразие**: Следуйте приведённым ниже шаблонам и используйте русский язык для консистентности.
- **Обновление**: Документация должна обновляться при изменении логики или интерфейса компонента.
- **Примеры**: Добавляйте примеры использования для сложных функций или методов.
- **Ссылки**: Используйте `@see` для ссылок на связанный код или документацию.

## 2. Базовая структура JSDoc
Каждый комментарий JSDoc начинается с `/**` и заканчивается `*/`. Минимальная структура включает:
- Описание назначения (одна-две строки).
- Теги для параметров, возвращаемых значений и исключений (если применимо).

Пример базового комментария:
```javascript
/**
 * Инициализирует экземпляр игры Phaser с заданной конфигурацией.
 * @param {Object} config - Объект конфигурации для игры Phaser.
 * @returns {Phaser.Game} Инициализированный экземпляр игры.
 */
function initGame(config) {
  return new Phaser.Game(config);
}
```

## 3. Правила для различных компонентов

### 3.1. Функции
- **Описание**: Указывайте, что делает функция и как она используется.
- **Теги**:
  - `@param` — для каждого параметра (тип, имя, описание).
  - `@returns` — возвращаемое значение (тип, описание).
  - `@throws` — возможные исключения (если есть).
  - `@example` — пример использования (опционально, но желательно для сложных функций).

Пример:
```javascript
/**
 * Отправляет команду перемещения на сервер Colyseus.
 * @param {string} roomId - Идентификатор комнаты для отправки команды.
 * @param {Object} position - Целевая позиция с координатами x и y.
 * @param {number} position.x - Координата X.
 * @param {number} position.y - Координата Y.
 * @returns {Promise<void>} Завершается, когда команда отправлена.
 * @throws {Error} Если roomId неверный или сервер недоступен.
 * @example
 * sendMoveCommand('room123', { x: 10, y: 20 });
 */
async function sendMoveCommand(roomId, position) {
  // Логика отправки команды
}
```

### 3.2. Классы
- **Описание**: Указывайте назначение класса и его роль в проекте.
- **Теги**:
  - `@class` или `@constructor` — для обозначения класса.
  - `@param` — для параметров конструктора.
  - Документируйте все публичные методы отдельно.

Пример:
```javascript
/**
 * Управляет позицией и перемещением игрока в сцене Phaser.
 * @class
 * @param {Phaser.Scene} scene - Экземпляр сцены Phaser.
 * @param {number} startX - Начальная позиция X.
 * @param {number} startY - Начальная позиция Y.
 */
class PlayerController {
  constructor(scene, startX, startY) {
    this.scene = scene;
    this.x = startX;
    this.y = startY;
  }

  /**
   * Обновляет позицию игрока на основе ввода.
   * @param {number} newX - Новая координата X.
   * @param {number} newY - Новая координата Y.
   */
  updatePosition(newX, newY) {
    this.x = newX;
    this.y = newY;
  }
}
```

### 3.3. Методы классов
- Документируйте каждый публичный метод внутри класса отдельным JSDoc-блоком.
- Используйте `@memberof` для указания принадлежности к классу (опционально).

Пример (из класса выше):
```javascript
/**
 * Обновляет позицию игрока на основе ввода.
 * @param {number} newX - Новая координата X.
 * @param {number} newY - Новая координата Y.
 * @memberof PlayerController
 */
updatePosition(newX, newY) {
  this.x = newX;
  this.y = newY;
}
```

### 3.4. Модули
- **Описание**: Указывайте назначение модуля в начале файла.
- **Тег**: `@module` — для обозначения модуля.
- Экспортируемые элементы документируются отдельно.

Пример:
```javascript
/**
 * Утилиты для управления конфигурацией игры и переменными окружения.
 * @module config
 */

/**
 * Загружает переменные окружения для указанной среды.
 * @param {string} env - Название среды (например, 'dev', 'prod').
 * @returns {Object} Объект конфигурации с загруженными переменными.
 */
export function loadConfig(env) {
  // Логика загрузки конфигурации
}
```

### 3.5. Переменные и константы
- **Описание**: Указывайте, что хранит переменная и как она используется.
- **Тег**: `@type` — для указания типа данных.

Пример:
```javascript
/**
 * Стандартная конфигурация для экземпляра игры Phaser.
 * @type {Object}
 * @property {number} width - Ширина игрового холста.
 * @property {number} height - Высота игрового холста.
 */
const DEFAULT_CONFIG = {
  width: 800,
  height: 600,
};
```

### 3.6. React-компоненты
- **Описание**: Укажите назначение компонента.
- **Теги**:
  - `@param` — для props (используйте `@typedef` для сложных типов).
  - `@returns` — всегда `{JSX.Element}`.

Пример:
```javascript
/**
 * Отображает холст игры Phaser внутри React-компонента.
 * @param {Object} props - Свойства компонента.
 * @param {boolean} props.isAuthenticated - Аутентифицирован ли пользователь.
 * @returns {JSX.Element} Элемент контейнера игры.
 */
export function PhaserGame({ isAuthenticated }) {
  return <div id="game-container"></div>;
}
```

### 3.7. Хуки
- **Описание**: Укажите, что делает хук и как его использовать.
- **Теги**:
  - `@returns` — массив или объект с возвращаемыми значениями.

Пример:
```javascript
/**
 * Управляет состоянием аутентификации пользователя через Supabase.
 * @returns {Object} Состояние аутентификации и методы.
 * @returns {Object|null} .user - Текущий аутентифицированный пользователь или null.
 * @returns {Function} .signIn - Выполняет вход пользователя по email и паролю.
 * @returns {Function} .signUp - Регистрирует нового пользователя.
 * @returns {Function} .signOut - Выполняет выход текущего пользователя.
 */
export function useAuth() {
  // Логика хука
}
```

## 4. Используемые теги
- `@param {тип} имя - описание` — параметры функции или метода.
- `@returns {тип} описание` — возвращаемое значение.
- `@throws {тип} описание` — возможные ошибки.
- `@type {тип}` — тип переменной или константы.
- `@typedef {тип} имя` — определение пользовательского типа (для сложных объектов).
- `@example` — пример использования.
- `@deprecated` — если компонент устарел (с указанием альтернативы).
- `@see` — ссылка на связанный код или документацию.
- `@todo` — задачи, которые нужно выполнить в будущем.

Пример сложного типа:
```javascript
/**
 * @typedef {Object} Position
 * @property {number} x - Координата X.
 * @property {number} y - Координата Y.
 */

/**
 * Перемещает игрока в новую позицию.
 * @param {Position} position - Целевая позиция.
 */
function movePlayer(position) {
  // Логика перемещения
}
```

## 5. Рекомендации по стилю
- **Типы**: Используйте встроенные типы JavaScript (`string`, `number`, `Object`) или кастомные (`Phaser.Scene`, `Colyseus.Room`).
- **Многострочные описания**: Разбивайте длинные описания на строки (до 80 символов).
- **Пробелы**: Добавляйте пустую строку между описанием и тегами.
- **Примеры**: Добавляйте `@example` для сложных функций или методов.

Пример многострочного описания:
```javascript
/**
 * Синхронизирует состояние игрока с комнатой Colyseus и обновляет сцену игры.
 * Этот метод гарантирует, что все клиенты видят одинаковые позиции игроков и
 * обрабатывает случаи задержек сети.
 *
 * @param {Colyseus.Room} room - Активный экземпляр комнаты Colyseus.
 * @param {Object} state - Текущее состояние игры с сервера.
 * @returns {void}
 */
function syncPlayerState(room, state) {
  // Логика синхронизации
}
```

## 6. Интеграция с проектом
- **Проверка**: Добавьте проверку наличия JSDoc в линтинг-процесс (например, через плагин `eslint-plugin-jsdoc`).

## 7. Исключения
- Приватные функции или методы (не экспортируемые) могут не документироваться, если их назначение очевидно из контекста.
- Простые геттеры/сеттеры в классах могут иметь краткое описание без тегов.

Пример исключения:
```javascript
// Не требует JSDoc, так как приватная и простая
function _calculateDistance(x1, y1, x2, y2) {
  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
}
```

---

# Дополнительные правила(помимо основных) для искуственного интелекта.
- Не удаляй комментарии и документацию кода.
- Не удаляй и не изменяй код, который не относится к задаче.
- Не оптимизируй код без необходимости и согласования с командой.
- Действуй в соответствии с принципами SOLID и DRY.
- Действуй как старший разработчик
- Пиши код так, чтобы его было легко читать и понимать.
- Не оставляй код недоделанным. Не останавливайся пока не реализуешь все требования полностью и до конца.
- Пиши код так, чтобы его было легко тестировать.
- Если это работа над ошибкой, то начинай с написания трех параграфов рассуждений, анализирующих причины возникновения ошибки и возможные пути ее устранения, не делай поспешных выводов. После этого приступай к исправлению ошибки.
- Начинай размышления с большой неуверенностью и постепенно набирай уверенность по мере размышлений над задачей.
- Каждый раз, когда ты встречаешься с проблемой, пытайся понять ее суть, а не просто найти решение.
- Разбивай задачи на подзадачи и решай их поочередно. Не пытайся решить все сразу.
- Используй официальные документации и руководства по использованию технологий и инструментов.
- Если есть выбор между простым и сложным решением, выбирайте простое, если оно решает задачу.
- Избегайте преждевременной оптимизации или избыточной абстракции