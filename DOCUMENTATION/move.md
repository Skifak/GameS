### План реализации механики перемещения в браузерной игре "Zone of Shadows" с учетом текущей структуры проекта

На основе предоставленных документов ("Zone of Shadows", "Технический README", "Правила разработки") и текущей структуры проекта я составлю детальный план реализации механики перемещения игроков по гексагональной сетке и редактора точек/путей с использованием React DnD. План будет учитывать существующие файлы, следовать принципам разработки (модульность, читаемость, DRY, SOLID и т.д.), и минимизировать дублирование кода. Реализация будет разбита на подзадачи с указанием, какие файлы модифицируются или создаются, чтобы интегрировать новую функциональность в текущую структуру.

---

### Цель
Реализовать механику перемещения игрока по узлам пути между точками интереса (POI) с визуализацией в Phaser.js и редактор для администраторов с использованием React DnD для управления POI и путями, синхронизируемыми через Supabase.

---

### Общие принципы реализации
1. **Модульность**: Используем существующую структуру (`src/game`, `src/components`, `server`) и добавим новые модули только при необходимости.
2. **Атомарность**: Каждый модуль будет отвечать за одну задачу (например, `PlayerController.js` — за позицию игрока, `MapEditor.jsx` — за редактирование карты).
3. **Читаемость**: Имена файлов и функций будут понятными (например, `moveToNode`, `renderPath`), с JSDoc-документацией.
4. **DRY**: Повторяющаяся логика (например, запросы к Supabase) останется в `MapDataManager.js` и `supabase.js`.
5. **Тестируемость**: Модули будут независимыми, с передачей зависимостей через параметры.
6. **Асинхронность**: Сетевые операции (Colyseus, Supabase) будут использовать `async/await` с обработкой ошибок.
7. **Безопасность**: Редактирование карты доступно только администраторам с проверкой на сервере (`admin.js`).

---

### Подзадачи

#### 1. Подготовка инфраструктуры
- **Цель**: Подготовить проект к добавлению новой функциональности.
- **Шаги**:
  1. Проверить актуальность зависимостей в `package.json` (Phaser.js, Colyseus, Supabase).
  2. Установить React DnD:
     - Команда: `npm install react-dnd react-dnd-html5-backend`.
     - Обновить `package.json`.
  3. Убедиться, что миграции Supabase актуальны:
     - Проверить `supabase/migrations/20250316190345_create_points_of_interest.sql` и `20250316190346_create_point_transitions.sql` на наличие полей для узлов и событий.
     - При необходимости добавить поле `node_events` в `point_transitions` через новую миграцию (`20250323120000_add_node_events.sql`).
  4. Создать ветку `feature/movement-and-map-editor` для разработки.
- **Файлы**:
  - `package.json` — обновление зависимостей.
  - `supabase/migrations/20250323120000_add_node_events.sql` — новая миграция (если требуется).
- **Результат**: Проект готов к разработке с установленными зависимостями и актуальной базой данных.

#### 2. Механика перемещения игрока
##### 2.1. Отображение путей
- **Цель**: Показать игроку доступные пути между POI на гексагональной сетке.
- **Шаги**:
  1. Обновить `src/game/scenes/HexGrid.js`:
     - Добавить метод для рендеринга путей (линий между узлами) с использованием Phaser.Graphics.
     - Реализовать обработчик клика по POI, который вызывает метод в `MapDataManager.js` для получения путей.
     - Подсветить активный путь (например, зелёный цвет) и оставить остальные пути серыми.
  2. Обновить `src/game/MapDataManager.js`:
     - Добавить метод `fetchPathsForPoint(pointId)` для запроса путей из Supabase (`point_transitions`).
     - Кэшировать пути локально для оптимизации.
  3. Обновить `src/game/scenes/Game.js`:
     - Передать данные путей из `HexGrid.js` для дальнейшей обработки.
- **Файлы**:
  - `src/game/scenes/HexGrid.js` — рендеринг и интерактивность путей.
  - `src/game/MapDataManager.js` — загрузка путей.
  - `src/game/scenes/Game.js` — координация.
- **Результат**: Игрок видит пути при клике на POI.

##### 2.2. Логика перемещения
- **Цель**: Реализовать движение игрока по узлам пути с анимацией.
- **Шаги**:
  1. Обновить `src/components/PlayerController.js`:
     - Добавить метод `moveToNode(nodeId, callback)` для перемещения к конкретному узлу.
     - Использовать Phaser Tween для анимации в сцене.
  2. Обновить `src/game/CommandSender.js`:
     - Добавить команду `move` с параметрами `{ pathId, nodeId }` для отправки в Colyseus.
  3. Обновить `server/pointRoom.js`:
     - Валидировать команду `move` (проверка пути, энергии игрока).
     - Обновлять состояние комнаты и отправлять клиентам.
  4. Обновить `src/game/MessageHandler.js`:
     - Обрабатывать ответ от Colyseus и вызывать `moveToNode` в `PlayerController.js`.
  5. Обновить `src/game/scenes/Game.js`:
     - Координировать процесс: выбор пути → отправка команды → запуск анимации.
- **Файлы**:
  - `src/components/PlayerController.js` — управление перемещением.
  - `src/game/CommandSender.js` — отправка команды.
  - `server/pointRoom.js` — серверная логика.
  - `src/game/MessageHandler.js` — обработка ответа.
  - `src/game/scenes/Game.js` — координация.
- **Результат**: Игрок движется по узлам с анимацией.

##### 2.3. События на узлах
- **Цель**: Добавить случайные события при достижении узлов.
- **Шаги**:
  1. Обновить `src/game/MapDataManager.js`:
     - Добавить загрузку `node_events` из `point_transitions`.
  2. Обновить `src/game/scenes/Game.js`:
     - Создать метод `handleNodeEvent(node)` для проверки и запуска событий (бой, аномалия).
     - Использовать `UIManager.js` для отображения уведомлений о событиях.
  3. Обновить `src/components/UIManager.js`:
     - Добавить метод `showEventNotification(eventType)` для вывода текста (например, "Мутант атакует!").
- **Файлы**:
  - `src/game/MapDataManager.js` — загрузка событий.
  - `src/game/scenes/Game.js` — обработка событий.
  - `src/components/UIManager.js` — уведомления.
- **Результат**: Перемещение сопровождается событиями.

##### 2.4. Управление энергией
- **Цель**: Ограничить перемещение энергией игрока.
- **Шаги**:
  1. Обновить миграцию `supabase/migrations/20250320220000_add_hex_position_to_profiles.sql`:
     - Добавить поле `energy` в таблицу `profiles` (например, `integer DEFAULT 100`).
  2. Обновить `src/game/GameStateManager.js`:
     - Добавить метод `updateEnergy(amount)` для изменения энергии.
     - Проверять энергию перед перемещением.
  3. Обновить `server/pointRoom.js`:
     - Валидировать энергию на сервере перед подтверждением перемещения.
  4. Обновить `src/components/UIManager.js`:
     - Добавить уведомление при недостатке энергии ("Недостаточно энергии!").
- **Файлы**:
  - `supabase/migrations/20250323120001_add_energy_to_profiles.sql` — новая миграция.
  - `src/game/GameStateManager.js` — управление энергией.
  - `server/pointRoom.js` — серверная валидация.
  - `src/components/UIManager.js` — уведомления.
- **Результат**: Перемещение зависит от энергии.

#### 3. Реализация редактора карты
##### 3.1. Создание интерфейса редактора
- **Цель**: Построить интерфейс для редактирования карты.
- **Шаги**:
  1. Создать `src/components/MapEditor.jsx`:
     - Отображать `HexGrid.js` в режиме редактирования.
     - Добавить панель свойств для настройки POI и путей.
  2. Обновить `src/App.jsx`:
     - Показывать `MapEditor.jsx` только для пользователей с ролью `admin` (проверка через `useAuth.js`).
  3. Обновить `src/hooks/useAuth.js`:
     - Добавить получение роли пользователя из Supabase.
- **Файлы**:
  - `src/components/MapEditor.jsx` — новый компонент.
  - `src/App.jsx` — условный рендеринг.
  - `src/hooks/useAuth.js` — проверка роли.
- **Результат**: Админ видит редактор.

##### 3.2. Drag-and-Drop для точек
- **Цель**: Реализовать управление POI через React DnD.
- **Шаги**:
  1. В `src/components/MapEditor.jsx`:
     - Настроить DnD для перетаскивания POI (тип `"point"`).
     - Реализовать добавление точки через форму (POST `/api/points`).
     - Реализовать перемещение точки с обновлением координат (PUT `/api/points/:id`).
  2. Обновить `server/admin.js`:
     - Добавить эндпоинты для CRUD операций с POI, с проверкой роли `admin`.
- **Файлы**:
  - `src/components/MapEditor.jsx` — DnD и CRUD.
  - `server/admin.js` — серверные эндпоинты.
- **Результат**: Админ управляет POI через DnD.

##### 3.3. Редактирование путей
- **Цель**: Реализовать управление путями.
- **Шаги**:
  1. В `src/components/MapEditor.jsx`:
     - Добавить создание пути через выбор POI и клики по узлам (POST `/api/paths`).
     - Реализовать перемещение узлов через DnD (PUT `/api/paths/:id`).
     - Добавить удаление узлов/путей (DELETE `/api/paths/:id`).
  2. Обновить `server/admin.js`:
     - Добавить эндпоинты для CRUD операций с путями.
- **Файлы**:
  - `src/components/MapEditor.jsx` — управление путями.
  - `server/admin.js` — серверные эндпоинты.
- **Результат**: Админ управляет путями.

##### 3.4. Синхронизация с Supabase
- **Цель**: Обеспечить real-time обновления карты.
- **Шаги**:
  1. Обновить `src/lib/supabase.js`:
     - Добавить подписку на изменения в `points_of_interest` и `point_transitions` через `supabase.realtime`.
  2. Обновить `src/components/MapEditor.jsx`:
     - Обновлять состояние при получении изменений от Supabase.
  3. Обновить `src/game/scenes/HexGrid.js`:
     - Реагировать на изменения для игроков.
- **Файлы**:
  - `src/lib/supabase.js` — подписка.
  - `src/components/MapEditor.jsx` — обновление редактора.
  - `src/game/scenes/HexGrid.js` — обновление для игроков.
- **Результат**: Изменения карты видны в реальном времени.

---

### Итоговый результат
- **Игрок**: Кликает на POI → видит пути → выбирает путь → остальные пути скрываются → игрок движется по узлам выбранного пути с анимацией и событиями на узлах, а так же теряет энергию при перемещении.
- **Админ**: Использует `MapEditor.jsx` для добавления, перемещения и удаления POI/путей через DnD, с синхронизацией в Supabase.

---

### Последующие шаги
1. **Тестирование**:
   - Юнит-тесты для `PlayerController.js` и `MapEditor.jsx` (Jest).
   - E2E-тесты для сценария перемещения (Cypress).
2. **Коммиты**:
   - Использовать структуру: `feat(game): Добавить рендеринг путей в HexGrid`.
3. **Деплой**:
   - Проверить на `stage` через GitHub Actions перед слиянием в `main`.
