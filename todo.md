### ToDo

#### 1. Настройка безопасной аутентификации через Supabase
- **Описание**: Реализовать вход с использованием refresh токенов и короткоживущих JWT через Express с базовым логированием и обработкой ошибок.
- **Подзадачи**:
  + Настроить Supabase Auth для выдачи JWT (TTL дефолный) и refresh токенов (хранить в HTTP-only куки с `SameSite=Strict`).
    - Настроен Supabase Auth с использованием JWT и refresh токенов (через Supabase SDK), используется дефолтный TTL Supabase.
  + Обновить `AuthForm.jsx` для обработки входа и получения токенов, с пуш-уведомлением "Вход выполнен" при успехе.
    - В src\components\AuthForm.jsx реализована обработка входа и получения токенов с пуш-уведомлением "Вход выполнен" через react-toastify.
  - Реализовать эндпоинт на Express (`/refresh`) для обновления JWT по refresh токену.
    - Эндпоинт /refresh для обновления JWT по refresh токену не реализован на сервере.
  - Добавить middleware в Express для проверки JWT перед всеми запросами (включая Colyseus), с логированием "Игрок <username> попытался войти" и обработкой ошибок (лог + алерт "Сервер временно недоступен").
    - Middleware в Express для проверки JWT перед запросами реализован (server\index.js:authMiddleware), но логирование "Игрок <username> попытался войти" есть только в формате email (logger.info), а не username. Также нет явного алерта "Сервер временно недоступен" при ошибках Supabase.
- **Доделать**
  - Реализовать эндпоинт /refresh на Express для обновления JWT по refresh токену.
  - Добавить управление HTTP-only куки с SameSite=Strict для refresh токенов.
  - В middleware Express добавить логирование username вместо email и алерт "Сервер временно недоступен" для игрока при ошибках Supabase.
  - Добавить проверку токена перед подключением к Colyseus (частично сделано, но требует доработки для единообразия логирования).
- **Детали**:
  + Валидация токена через Supabase SDK в middleware Express.
    - Валидация токена через Supabase SDK в middleware Express реализована.
  - Защита от CSRF через `SameSite=Strict` в куки.
    - Защита от CSRF через SameSite=Strict в куки не реализована (нет явного управления куки в коде).
  + Логирование через Winston/Loki, единичные записи (без повторов для одного действия).
  - При ошибке Supabase (например, недоступность сервиса) — лог ошибки и алерт игроку.
    - Обработка ошибок Supabase (например, недоступность сервиса) логируется, но алерта игроку нет.
- **Результат**: Игрок входит через форму, получает токены, видит пуш "Вход выполнен", ошибки обрабатываются с алертом.

#### 2. Создание и интеграция профиля игрока
- **Описание**: Создать таблицу `profiles` в Supabase с расширенными полями, валидацией и интеграцией с клиентом/сервером.
- **Подзадачи**:
  + Создать таблицу `profiles` в Supabase с полями:
    - `id` (UUID, ссылка на `auth.users`),
    - `username` (TEXT, уникальное, 3-20 символов, только буквы и цифры),
    - `name` (TEXT),
    - `email` (TEXT, валидный формат email),
    - `role` (TEXT, ограничение: `player`, `admin`, `moderator`, `clan_leader`, `quest_editor`, `banned`, по умолчанию `player`),
    - `created_at` (TIMESTAMP, по умолчанию `NOW()`),
    - `last_login` (TIMESTAMP, обновлять серверным временем UTC при входе),
    - `status` (TEXT, `online`/`offline`, по умолчанию `offline`).
      - Таблица profiles создана в Supabase (supabase\migrations\20250316190343_init_schema.sql) с указанными полями и ограничениями.
  + Обновить `AuthForm.jsx` для проверки/создания профиля после входа (валидация `username` и `email`, создание с `role = 'player'`, `status = 'online'`).
    - AuthForm.jsx проверяет и создает профиль после входа (валидация username и email есть, создание с role='player', status='online').
  - В middleware Express: если `role = 'banned'`, возвращать ошибку с пуш-уведомлением "Вход заблокирован".
    - Middleware в Express (server\index.js:HexRoom.onAuth) проверяет role='banned' и выбрасывает ошибку, но пуш-уведомление "Вход заблокирован" не реализовано (нет механизма отправки уведомлений на клиент).
  - Логировать вход: "Игрок <username> вошел" (единичный лог).
    - Логирование входа ("Игрок <username> вошел") реализовано в server\index.js:HexRoom.onJoin, но не в useAuth.js при успешном входе.
- **Доделать**
  - Добавить пуш-уведомление "Вход заблокирован" для забаненных пользователей через react-toastify.
  - Добавить логирование "Игрок <username> вошел" в useAuth.js после успешного входа.
- **Детали**:
  - `id` генерируется Supabase, `username`, `name`, `email` вводятся игроком с валидацией, `password` хранится в `auth.users`.
  - Валидация: `username` — 3-20 символов (a-z, A-Z, 0-9), `email` — стандартный формат (через regex или Supabase).
    - Валидация полей (username, email) реализована через regex в AuthForm.jsx и через CHECK в SQL.
  - Роли меняются позже через админ-модуль.
- **Результат**: Игрок получает профиль с валидными данными, забаненные видят пуш "Вход заблокирован", вход логируется.

#### 3. Настройка Redis для хранения сессий
- **Описание**: Реализовать хранение сессий игроков в Redis с выгрузкой на диск, логированием и обработкой ошибок.
- **Подзадачи**:
  - Настроить структуру сессии в Redis: ключ `player:<user_id>:session`, значение — JSON с полями `{ "location": { "map", "hex" }, "health", "actionPoints", "hunger", "sleepiness", "last_updated" }` (время в UTC).
    - Подключение к Redis настроено (server\index.js:initRedis), но структура сессий (player:<user_id>:session) не реализована.
  - Обновлять сессию в Redis при смене значений (перемещение, изменение ОЗ/ОД, потребностей), с логированием "Сессия игрока <user_id> обновлена".
    - Обновление сессий в Redis при изменении значений не реализовано.
  - Установить TTL 1 час (3600 секунд) для сессий.
    - TTL 1 час для сессий не установлен.
  + Создать таблицу `player_sessions` в Supabase: `user_id` (UUID), `session_data` (JSONB), `saved_at` (TIMESTAMP, UTC).
    - Таблица player_sessions создана в Supabase с указанными полями.
  - Настроить выгрузку сессии в Supabase при истечении TTL (через Redis Keyspace Notifications или проверку), с логом "Сессия игрока <user_id> выгружена на диск".
    - Выгрузка сессий в Supabase при истечении TTL не реализована (нет Keyspace Notifications или проверки).
  - При входе проверять `player_sessions` в Supabase и загружать сессию в Redis с логом "Сессия игрока <user_id> восстановлена с диска".
    - Загрузка сессий из Supabase в Redis при входе не реализована.
  - При ошибке Redis (например, недоступность) — лог ошибки и алерт "Сервер временно недоступен".
    - Обработка ошибок Redis логируется, но алерта "Сервер временно недоступен" нет.
- **Доделать**:
  - Реализовать структуру сессии в Redis (player:<user_id>:session) с JSON-полями { "location": { "map", "hex" }, "health", "actionPoints", "hunger", "sleepiness", "last_updated" }.
  - Настроить обновление сессий в Redis при значимых изменениях (перемещение, изменение ОЗ/ОД, потребностей).
  - Установить TTL 1 час для сессий в Redis.
  - Реализовать выгрузку сессий в Supabase при истечении TTL через Redis Keyspace Notifications или периодическую проверку.
  - Реализовать загрузку сессий из Supabase в Redis при входе игрока.
  - Добавить алерт "Сервер временно недоступен" при ошибках Redis.
- **Детали**:
  - Обновление только при значимых изменениях.
  - Начальные значения потребностей без роста (добавим позже).
  - Логирование через Winston/Loki, единичные записи.
- **Результат**: Сессия хранится в Redis, выгружается в Supabase через час, восстанавливается с логированием, ошибки обрабатываются.

#### 4. Базовая визуализация карты для MVP
- **Описание**: Реализовать отображение локации с гексами и механикой камеры.
- **Подзадачи**:
  - В `HexGrid.js` отрисовать карту локации (фон) с гексагональной сеткой (100-300 гексов) с прозрачностью 70%.
    - В HexGrid.js реализована отрисовка гексагональной сетки (100-300 гексов) с прозрачностью 70%.
  - Присваивать каждому гексу цвет в зависимости от типа (нейтральный, свободный и т.д.), данные запрашивать через Express.
   - Присвоение цветов гексам в зависимости от типа не реализовано (все гексы одного цвета — 0xaaaaaa).
  + Реализовать механику камеры: камера следует за маркером игрока, останавливается у границ локации.
   - Механика камеры реализована: камера следует за маркером игрока, останавливается у границ локации (Game.js).
  - Добавить скроллинг масштаба через колесо мыши с минимальным (0.5x) и максимальным (2x) значениями, изначально максимальный масштаб.
   - Система масштабирования через колесо мыши не реализована.
- **Доделать**:
  - Реализовать запрос данных о типах гексов через Express и присваивать цвета в зависимости от типа.
  - Добавить масштабирование через колесо мыши с минимальным (0.5x) и максимальным (2x) значениями, изначально максимальный масштаб.
  - Уточнить размер локации (100-300 гексов) и проверить соответствие.
- **Детали**:
  - Пока без точек и путей внутри гексов.
  - Размер локации — 100-300 гексов (уточним позже).
- **Результат**: Игрок видит карту с гексами, может масштабировать и перемещать камеру.

#### 5. Интеграция Colyseus для гексов
- **Описание**: Настроить комнаты Colyseus с аутентификацией через Express.
- **Подзадачи**:
  + Создать комнату `HexRoom` с базовым лимитом 10-20 игроков.
    - Комната HexRoom создана с лимитом 10-20 игроков (server\index.js:HexRoom).
  - При переполнении создавать новую комнату для того же гекса.
    - Создание новых комнат при переполнении не реализовано.
  - Синхронизировать состояние гекса между комнатами через Redis (ключ `hex:<map>:<q>:<r>`).
    - Синхронизация состояния гекса через Redis не реализована.
  + Использовать Express middleware для проверки токена перед подключением к Colyseus.
    - Проверка токена через Express middleware перед подключением к Colyseus реализована (HexRoom.onAuth).
  + Логировать подключение: "Игрок <username> подключился к комнате <room_id>".
    - Логирование подключения "Игрок <username> подключился к комнате <room_id>" реализовано.
- **Доделать**:
  - Реализовать создание новых комнат при переполнении текущей.
  - Настроить синхронизацию состояния гекса между комнатами через Redis (hex:<map>:<q>:<r>).
  - Добавить сложную логику взаимодействия в комнатах (пока только подключение).
- **Детали**:
  - Новые комнаты создаются автоматически.
  - Пока без сложной логики — только подключение.
- **Результат**: Игроки подключаются к гексу через Express, при переполнении создается новая комната.

#### 6. Тестирование и документация
- **Описание**: Обеспечить тестирование и документирование кода.
- **Подзадачи**:
  - Написать Jest тесты для аутентификации (вход, проверка токена, создание профиля).
    - Jest тесты для аутентификации не написаны.
  - Написать тесты для Redis (сохранение, загрузка, выгрузка сессии).
    - Тесты для Redis не написаны.
  - Документировать код с помощью JSDoc (функции входа, middleware, работа с Redis).
    - Документация через JSDoc есть в большинстве файлов, но не везде полная (например, в HexGrid.js нет описания параметров методов).
- **Доделать**:
  - Написать Jest тесты для аутентификации (вход, проверка токена, создание профиля).
  - Написать тесты для Redis (сохранение, загрузка, выгрузка сессии).
  - Дополнить JSDoc-документацию для всех функций, особенно в HexGrid.js, Game.js.
- **Детали**:
  - Тесты покрывают базовые сценарии (вход, бан, восстановление сессии).
  - JSDoc для каждой функции с описанием параметров и возвращаемых значений.
- **Результат**: Код протестирован и задокументирован.

---