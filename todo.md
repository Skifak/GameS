### ToDo

#### 1. Настройка безопасной аутентификации через Supabase
- **Описание**: Реализовать вход с использованием refresh токенов и короткоживущих JWT через Express с базовым логированием и обработкой ошибок.
- **Подзадачи**:
  + Настроить Supabase Auth для выдачи JWT (TTL дефолный) и refresh токенов (хранить в HTTP-only куки с `SameSite=Strict`).
    - Настроен Supabase Auth с использованием JWT и refresh токенов (через Supabase SDK), используется дефолтный TTL Supabase.
  + Обновить `AuthForm.jsx` для обработки входа и получения токенов, с пуш-уведомлением "Вход выполнен" при успехе.
    - В src\components\AuthForm.jsx реализована обработка входа и получения токенов с пуш-уведомлением "Вход выполнен" через react-toastify.
  - Реализовать эндпоинт на Express (`/refresh`) для обновления JWT по refresh токену.
    - Эндпоинт /refresh для обновления JWT по refresh токену не реализован на сервере.
  - Добавить middleware в Express для проверки JWT перед всеми запросами (включая Colyseus), с логированием "Игрок <username> попытался войти" и обработкой ошибок (лог + алерт "Сервер временно недоступен").
    - Middleware в Express для проверки JWT перед запросами реализован (server\index.js:authMiddleware), но логирование "Игрок <username> попытался войти" есть только в формате email (logger.info), а не username. Также нет явного алерта "Сервер временно недоступен" при ошибках Supabase.
- **Доделать**
  - Реализовать эндпоинт /refresh на Express для обновления JWT по refresh токену.
  - Добавить управление HTTP-only куки с SameSite=Strict для refresh токенов.
  - В middleware Express добавить логирование username вместо email и алерт "Сервер временно недоступен" для игрока при ошибках Supabase.
  - Добавить проверку токена перед подключением к Colyseus (частично сделано, но требует доработки для единообразия логирования).
- **Детали**:
  + Валидация токена через Supabase SDK в middleware Express.
    - Валидация токена через Supabase SDK в middleware Express реализована.
  - Защита от CSRF через `SameSite=Strict` в куки.
    - Защита от CSRF через SameSite=Strict в куки не реализована (нет явного управления куки в коде).
  + Логирование через Winston/Loki, единичные записи (без повторов для одного действия).
  - При ошибке Supabase (например, недоступность сервиса) — лог ошибки и алерт игроку.
    - Обработка ошибок Supabase (например, недоступность сервиса) логируется, но алерта игроку нет.
- **Результат**: Игрок входит через форму, получает токены, видит пуш "Вход выполнен", ошибки обрабатываются с алертом.

#### 2. Создание и интеграция профиля игрока
- **Описание**: Создать таблицу `profiles` в Supabase с расширенными полями, валидацией и интеграцией с клиентом/сервером.
- **Подзадачи**:
  + Создать таблицу `profiles` в Supabase с полями:
    - `id` (UUID, ссылка на `auth.users`),
    - `username` (TEXT, уникальное, 3-20 символов, только буквы и цифры),
    - `name` (TEXT),
    - `email` (TEXT, валидный формат email),
    - `role` (TEXT, ограничение: `player`, `admin`, `moderator`, `clan_leader`, `quest_editor`, `banned`, по умолчанию `player`),
    - `created_at` (TIMESTAMP, по умолчанию `NOW()`),
    - `last_login` (TIMESTAMP, обновлять серверным временем UTC при входе),
    - `status` (TEXT, `online`/`offline`, по умолчанию `offline`).
      - Таблица profiles создана в Supabase (supabase\migrations\20250316190343_init_schema.sql) с указанными полями и ограничениями.
  + Обновить `AuthForm.jsx` для проверки/создания профиля после входа (валидация `username` и `email`, создание с `role = 'player'`, `status = 'online'`).
    - AuthForm.jsx проверяет и создает профиль после входа (валидация username и email есть, создание с role='player', status='online').
  - В middleware Express: если `role = 'banned'`, возвращать ошибку с пуш-уведомлением "Вход заблокирован".
    - Middleware в Express (server\index.js:HexRoom.onAuth) проверяет role='banned' и выбрасывает ошибку, но пуш-уведомление "Вход заблокирован" не реализовано (нет механизма отправки уведомлений на клиент).
  - Логировать вход: "Игрок <username> вошел" (единичный лог).
    - Логирование входа ("Игрок <username> вошел") реализовано в server\index.js:HexRoom.onJoin, но не в useAuth.js при успешном входе.
- **Доделать**
  - Добавить пуш-уведомление "Вход заблокирован" для забаненных пользователей через react-toastify.
  - Добавить логирование "Игрок <username> вошел" в useAuth.js после успешного входа.
- **Детали**:
  - `id` генерируется Supabase, `username`, `name`, `email` вводятся игроком с валидацией, `password` хранится в `auth.users`.
  - Валидация: `username` — 3-20 символов (a-z, A-Z, 0-9), `email` — стандартный формат (через regex или Supabase).
    - Валидация полей (username, email) реализована через regex в AuthForm.jsx и через CHECK в SQL.
  - Роли меняются позже через админ-модуль.
- **Результат**: Игрок получает профиль с валидными данными, забаненные видят пуш "Вход заблокирован", вход логируется.

#### 3. Настройка Redis для хранения сессий
- **Описание**: Реализовать хранение сессий игроков в Redis с выгрузкой на диск, логированием и обработкой ошибок.
- **Подзадачи**:
  - Настроить структуру сессии в Redis: ключ `player:<user_id>:session`, значение — JSON с полями `{ "location": { "map", "hex" }, "health", "actionPoints", "hunger", "sleepiness", "last_updated" }` (время в UTC).
    - Подключение к Redis настроено (server\index.js:initRedis), но структура сессий (player:<user_id>:session) не реализована.
  - Обновлять сессию в Redis при смене значений (перемещение, изменение ОЗ/ОД, потребностей), с логированием "Сессия игрока <user_id> обновлена".
    - Обновление сессий в Redis при изменении значений не реализовано.
  - Установить TTL 1 час (3600 секунд) для сессий.
    - TTL 1 час для сессий не установлен.
  + Создать таблицу `player_sessions` в Supabase: `user_id` (UUID), `session_data` (JSONB), `saved_at` (TIMESTAMP, UTC).
    - Таблица player_sessions создана в Supabase с указанными полями.
  - Настроить выгрузку сессии в Supabase при истечении TTL (через Redis Keyspace Notifications или проверку), с логом "Сессия игрока <user_id> выгружена на диск".
    - Выгрузка сессий в Supabase при истечении TTL не реализована (нет Keyspace Notifications или проверки).
  - При входе проверять `player_sessions` в Supabase и загружать сессию в Redis с логом "Сессия игрока <user_id> восстановлена с диска".
    - Загрузка сессий из Supabase в Redis при входе не реализована.
  - При ошибке Redis (например, недоступность) — лог ошибки и алерт "Сервер временно недоступен".
    - Обработка ошибок Redis логируется, но алерта "Сервер временно недоступен" нет.
- **Доделать**:
  - Реализовать структуру сессии в Redis (player:<user_id>:session) с JSON-полями { "location": { "map", "hex" }, "health", "actionPoints", "hunger", "sleepiness", "last_updated" }.
  - Настроить обновление сессий в Redis при значимых изменениях (перемещение, изменение ОЗ/ОД, потребностей).
  - Установить TTL 1 час для сессий в Redis.
  - Реализовать выгрузку сессий в Supabase при истечении TTL через Redis Keyspace Notifications или периодическую проверку.
  - Реализовать загрузку сессий из Supabase в Redis при входе игрока.
  - Добавить алерт "Сервер временно недоступен" при ошибках Redis.
- **Детали**:
  - Обновление только при значимых изменениях.
  - Начальные значения потребностей без роста (добавим позже).
  - Логирование через Winston/Loki, единичные записи.
- **Результат**: Сессия хранится в Redis, выгружается в Supabase через час, восстанавливается с логированием, ошибки обрабатываются.

#### 4. Базовая визуализация карты для MVP
- **Описание**: Реализовать отображение локации с гексами и механикой камеры.
- **Подзадачи**:
  - В `HexGrid.js` отрисовать карту локации (фон) с гексагональной сеткой (100-300 гексов) с прозрачностью 70%.
    - В HexGrid.js реализована отрисовка гексагональной сетки (100-300 гексов) с прозрачностью 70%.
  - Присваивать каждому гексу цвет в зависимости от типа (нейтральный, свободный и т.д.), данные запрашивать через Express.
   - Присвоение цветов гексам в зависимости от типа не реализовано (все гексы одного цвета — 0xaaaaaa).
  + Реализовать механику камеры: камера следует за маркером игрока, останавливается у границ локации.
   - Механика камеры реализована: камера следует за маркером игрока, останавливается у границ локации (Game.js).
  - Добавить скроллинг масштаба через колесо мыши с минимальным (0.5x) и максимальным (2x) значениями, изначально максимальный масштаб.
   - Система масштабирования через колесо мыши не реализована.
- **Доделать**:
  - Реализовать запрос данных о типах гексов через Express и присваивать цвета в зависимости от типа.
  - Добавить масштабирование через колесо мыши с минимальным (0.5x) и максимальным (2x) значениями, изначально максимальный масштаб.
  - Уточнить размер локации (100-300 гексов) и проверить соответствие.
- **Детали**:
  - Пока без точек и путей внутри гексов.
  - Размер локации — 100-300 гексов (уточним позже).
- **Результат**: Игрок видит карту с гексами, может масштабировать и перемещать камеру.

#### 5. Интеграция Colyseus для гексов
- **Описание**: Настроить комнаты Colyseus с аутентификацией через Express.
- **Подзадачи**:
  + Создать комнату `HexRoom` с базовым лимитом 10-20 игроков.
    - Комната HexRoom создана с лимитом 10-20 игроков (server\index.js:HexRoom).
  - При переполнении создавать новую комнату для того же гекса.
    - Создание новых комнат при переполнении не реализовано.
  - Синхронизировать состояние гекса между комнатами через Redis (ключ `hex:<map>:<q>:<r>`).
    - Синхронизация состояния гекса через Redis не реализована.
  + Использовать Express middleware для проверки токена перед подключением к Colyseus.
    - Проверка токена через Express middleware перед подключением к Colyseus реализована (HexRoom.onAuth).
  + Логировать подключение: "Игрок <username> подключился к комнате <room_id>".
    - Логирование подключения "Игрок <username> подключился к комнате <room_id>" реализовано.
- **Доделать**:
  - Реализовать создание новых комнат при переполнении текущей.
  - Настроить синхронизацию состояния гекса между комнатами через Redis (hex:<map>:<q>:<r>).
  - Добавить сложную логику взаимодействия в комнатах (пока только подключение).
- **Детали**:
  - Новые комнаты создаются автоматически.
  - Пока без сложной логики — только подключение.
- **Результат**: Игроки подключаются к гексу через Express, при переполнении создается новая комната.

#### 6. Тестирование и документация
- **Описание**: Обеспечить тестирование и документирование кода.
- **Подзадачи**:
  - Написать Jest тесты для аутентификации (вход, проверка токена, создание профиля).
    - Jest тесты для аутентификации не написаны.
  - Написать тесты для Redis (сохранение, загрузка, выгрузка сессии).
    - Тесты для Redis не написаны.
  - Документировать код с помощью JSDoc (функции входа, middleware, работа с Redis).
    - Документация через JSDoc есть в большинстве файлов, но не везде полная (например, в HexGrid.js нет описания параметров методов).
- **Доделать**:
  - Написать Jest тесты для аутентификации (вход, проверка токена, создание профиля).
  - Написать тесты для Redis (сохранение, загрузка, выгрузка сессии).
  - Дополнить JSDoc-документацию для всех функций, особенно в HexGrid.js, Game.js.
- **Детали**:
  - Тесты покрывают базовые сценарии (вход, бан, восстановление сессии).
  - JSDoc для каждой функции с описанием параметров и возвращаемых значений.
- **Результат**: Код протестирован и задокументирован.

---

======================================================================================================================================================
---

### Окончательная концепция

#### Основные требования
1. **Клиент только отрисовывает**:
   - Все данные (гексы, точки интереса, состояние игрока) загружаются с сервера через Colyseus или API.
   - Локального хранения данных на клиенте нет.

2. **Система гексов и перемещения**:
   - **Гексы**: Хранятся в Supabase в таблице `hexes`. Каждый гекс имеет тип (`neutral`, `free`, `danger`, `controlled`) и отображается цветом.
   - **Точки интереса**: Хранятся в Supabase в таблице `points_of_interest`. Типы: `camp`, `transition`, `normal`, `anomaly`, `faction`. Переходные точки (`transition`) связаны с точками в соседних гексах через таблицу `point_transitions`.
   - **Перемещение**:
     - Внутри гекса: игрок кликает на точку, маркер анимированно перемещается к ней.
     - Между гексами: игрок должен находиться на переходной точке (`transition`), в интерфейсе появляется кнопка "Перейти в другой гекс" (внизу по центру), при нажатии маркер перемещается в связанную точку соседнего гекса.

3. **Colyseus комнаты**:
   - Каждая точка интереса — это набор комнат Colyseus.
   - Максимальная вместимость одной комнаты: **10 игроков**.
   - При достижении 10 игроков создается новая комната (например, `point_<id>_room_1`, `point_<id>_room_2`).
   - Количество комнат на точку не ограничено.
   - На старте реализуем одну комнату на точку (до 10 игроков), масштабирование добавим позже.

4. **Администрирование карты**:
   - Блок администрирования: правый верхний угол, размер **350x500px**.
   - Кнопка "Войти в режим администрирования" активирует режим, отключает перемещение игрока и открывает функции управления.
   - Функции:
     - Управление гексами (смена типа по одному).
     - Создание/редактирование точек (координаты задаются кликом по карте).
     - Пути (заглушка для будущего).

#### Логика и механика

##### Структура данных на сервере
1. **Таблица `hexes`** (Supabase):
   - `id` (SERIAL PRIMARY KEY).
   - `q`, `r` (INTEGER, координаты гекса).
   - `type` (TEXT, CHECK: `neutral`, `free`, `danger`, `controlled`).

2. **Таблица `points_of_interest`** (Supabase):
   - `id` (SERIAL PRIMARY KEY).
   - `hex_q`, `hex_r` (INTEGER, привязка к гексу).
   - `type` (TEXT, CHECK: `camp`, `transition`, `normal`, `anomaly`, `faction`).
   - `x`, `y` (INTEGER, координаты в пикселях).

3. **Таблица `point_transitions`** (Supabase):
   - `id` (SERIAL PRIMARY KEY).
   - `from_point_id` (INTEGER, REFERENCES `points_of_interest(id)`).
   - `to_point_id` (INTEGER, REFERENCES `points_of_interest(id)`).

4. **Состояние игрока** (Colyseus или Redis):
   - `player_id` (UUID).
   - `current_point_id` (INTEGER, текущая точка).
   - `x`, `y` (INTEGER, координаты маркера).

##### Механика перемещения
- **Внутри гекса**:
  - Клиент запрашивает точки текущего гекса через Colyseus комнату.
  - Клик по точке отправляет запрос в комнату, сервер обновляет `current_point_id` и координаты игрока, клиент анимирует перемещение.
- **Между гексами**:
  - Если игрок на переходной точке (`type: 'transition'`), сервер проверяет связи в `point_transitions` и отправляет клиенту сигнал о доступности перехода.
  - Кнопка "Перейти в другой гекс" появляется внизу по центру интерфейса.
  - При нажатии клиент отправляет запрос серверу, сервер обновляет `current_point_id` и координаты, клиент анимирует переход.

##### Colyseus
- **Комната `PointRoom`**:
  - Идентификатор: `point_<id>_room_<number>` (например, `point_1_room_1`).
  - Лимит: 10 игроков.
  - При достижении лимита (в будущем) создается новая комната, синхронизация через NATS.
- **Синхронизация**:
  - На старте одна комната на точку, данные хранятся в состоянии комнаты Colyseus.
  - Позже: NATS для передачи состояния между комнатами одной точки (список игроков, события).

##### Администрирование
- **Активация**:
  - Проверка роли `admin` через Supabase (`profiles.role`).
  - Вход в режим отключает клики на точки для перемещения.
- **Функции**:
  1. **Гексы**: Смена типа одного гекса.
  2. **Точки**: Создание (клик по карте задает `x`, `y`) и редактирование.
  3. **Пути**: Заглушка.
- **Сохранение**:
  - Отправка изменений через API (`/admin/update-hex`, `/admin/create-point`).

#### Интерфейс админ-режима
- **Размер**: 350x500px, правый верхний угол.
- **Цвета**: `--woodsmoke` (фон), `--green` (акценты), `--silver-chalice` (текст).

##### Элементы
1. **Кнопка активации**:
   - "Войти в режим администрирования" (330x30px, обводка `--green`).
   - При активации: "Выйти из режима" (обводка `--ff6b6b`).

2. **Вкладки**:
   - "Гексы", "Точки", "Пути" (110x30px каждая).

3. **Содержимое**:
   - **Гексы**:
     - Список гексов (прокручиваемый, 400px):
       - "Гекс (q,r) - [тип]".
       - Клик выделяет гекс на карте (обводка `--orange`).
     - Выпадающий список типов.
     - Кнопка "Сохранить" (330x30px).
   - **Точки**:
     - Кнопка "Добавить точку" (330x30px, клик по карте задает координаты).
     - Список точек текущего гекса (прокручиваемый, 350px):
       - "Точка [id] - [тип] (x,y)".
       - Клик выделяет точку.
     - Поля: "Тип" (выпадающий список), "X", "Y" (числовые).
     - Кнопка "Сохранить" (330x30px).
   - **Пути**:
     - Текст: "Пути в разработке".

4. **Обратная связь**:
   - Уведомления внизу блока (зеленый `--green` или красный `--ff6b6b`).

##### Кнопка перехода
- "Перейти в другой гекс": внизу по центру интерфейса, появляется только на переходной точке.

---

### План реализации
1. **Сервер**:
   - Миграции для `hexes`, `points_of_interest`, `point_transitions`.
   - API для администрирования (`/admin/*`).
   - Colyseus `PointRoom` (одна комната на точку, до 10 игроков).

2. **Клиент**:
   - Обновить `HexGrid.js` для отрисовки гексов и точек с сервера.
   - Обновить `Game.js` для работы с Colyseus и перемещения.
   - Добавить админ-блок в `App.jsx` (React-компонент).

3. **NATS**: Отложить до масштабирования.

---

### Подтверждение
Все устраивает? Если да, я начну с миграций и серверной части. Если есть что добавить или изменить — говори! 😊