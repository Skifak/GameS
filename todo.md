### ToDo

#### 1. Настройка безопасной аутентификации через Supabase
- **Описание**: Реализовать вход с использованием refresh токенов и короткоживущих JWT через Express с базовым логированием и обработкой ошибок.
- **Подзадачи**:
  - Настроить Supabase Auth для выдачи JWT (TTL 15 минут) и refresh токенов (хранить в HTTP-only куки с `SameSite=Strict`).
  - Обновить `AuthForm.jsx` для обработки входа и получения токенов, с пуш-уведомлением "Вход выполнен" при успехе.
  - Реализовать эндпоинт на Express (`/refresh`) для обновления JWT по refresh токену.
  - Добавить middleware в Express для проверки JWT перед всеми запросами (включая Colyseus), с логированием "Игрок <username> попытался войти" и обработкой ошибок (лог + алерт "Сервер временно недоступен").
- **Детали**:
  - Валидация токена через Supabase SDK в middleware Express.
  - Защита от CSRF через `SameSite=Strict` в куки.
  - Логирование через Winston/Loki, единичные записи (без повторов для одного действия).
  - При ошибке Supabase (например, недоступность сервиса) — лог ошибки и алерт игроку.
- **Результат**: Игрок входит через форму, получает токены, видит пуш "Вход выполнен", ошибки обрабатываются с алертом.

#### 2. Создание и интеграция профиля игрока
- **Описание**: Создать таблицу `profiles` в Supabase с расширенными полями, валидацией и интеграцией с клиентом/сервером.
- **Подзадачи**:
  - Создать таблицу `profiles` в Supabase с полями:
    - `id` (UUID, ссылка на `auth.users`),
    - `username` (TEXT, уникальное, 3-20 символов, только буквы и цифры),
    - `name` (TEXT),
    - `email` (TEXT, валидный формат email),
    - `role` (TEXT, ограничение: `player`, `admin`, `moderator`, `clan_leader`, `quest_editor`, `banned`, по умолчанию `player`),
    - `created_at` (TIMESTAMP, по умолчанию `NOW()`),
    - `last_login` (TIMESTAMP, обновлять серверным временем UTC при входе),
    - `status` (TEXT, `online`/`offline`, по умолчанию `offline`).
  - Обновить `AuthForm.jsx` для проверки/создания профиля после входа (валидация `username` и `email`, создание с `role = 'player'`, `status = 'online'`).
  - В middleware Express: если `role = 'banned'`, возвращать ошибку с пуш-уведомлением "Вход заблокирован".
  - Логировать вход: "Игрок <username> вошел" (единичный лог).
- **Детали**:
  - `id` генерируется Supabase, `username`, `name`, `email` вводятся игроком с валидацией, `password` хранится в `auth.users`.
  - Валидация: `username` — 3-20 символов (a-z, A-Z, 0-9), `email` — стандартный формат (через regex или Supabase).
  - Роли меняются позже через админ-модуль.
- **Результат**: Игрок получает профиль с валидными данными, забаненные видят пуш "Вход заблокирован", вход логируется.

#### 3. Настройка Redis для хранения сессий
- **Описание**: Реализовать хранение сессий игроков в Redis с выгрузкой на диск, логированием и обработкой ошибок.
- **Подзадачи**:
  - Настроить структуру сессии в Redis: ключ `player:<user_id>:session`, значение — JSON с полями `{ "location": { "map", "hex" }, "health", "actionPoints", "hunger", "sleepiness", "last_updated" }` (время в UTC).
  - Обновлять сессию в Redis при смене значений (перемещение, изменение ОЗ/ОД, потребностей), с логированием "Сессия игрока <user_id> обновлена".
  - Установить TTL 1 час (3600 секунд) для сессий.
  - Создать таблицу `player_sessions` в Supabase: `user_id` (UUID), `session_data` (JSONB), `saved_at` (TIMESTAMP, UTC).
  - Настроить выгрузку сессии в Supabase при истечении TTL (через Redis Keyspace Notifications или проверку), с логом "Сессия игрока <user_id> выгружена на диск".
  - При входе проверять `player_sessions` в Supabase и загружать сессию в Redis с логом "Сессия игрока <user_id> восстановлена с диска".
  - При ошибке Redis (например, недоступность) — лог ошибки и алерт "Сервер временно недоступен".
- **Детали**:
  - Обновление только при значимых изменениях.
  - Начальные значения потребностей без роста (добавим позже).
  - Логирование через Winston/Loki, единичные записи.
- **Результат**: Сессия хранится в Redis, выгружается в Supabase через час, восстанавливается с логированием, ошибки обрабатываются.

#### 4. Базовая визуализация карты для MVP
- **Описание**: Реализовать отображение локации с гексами и механикой камеры.
- **Подзадачи**:
  - В `HexGrid.js` отрисовать карту локации (фон) с гексагональной сеткой (100-300 гексов) с прозрачностью 70%.
  - Присваивать каждому гексу цвет в зависимости от типа (нейтральный, свободный и т.д.), данные запрашивать через Express.
  - Реализовать механику камеры: камера следует за маркером игрока, останавливается у границ локации.
  - Добавить скроллинг масштаба через колесо мыши с минимальным (0.5x) и максимальным (2x) значениями, изначально максимальный масштаб.
- **Детали**:
  - Пока без точек и путей внутри гексов.
  - Размер локации — 100-300 гексов (уточним позже).
- **Результат**: Игрок видит карту с гексами, может масштабировать и перемещать камеру.

#### 5. Интеграция Colyseus для гексов
- **Описание**: Настроить комнаты Colyseus с аутентификацией через Express.
- **Подзадачи**:
  - Создать комнату `HexRoom` с базовым лимитом 10-20 игроков.
  - При переполнении создавать новую комнату для того же гекса.
  - Синхронизировать состояние гекса между комнатами через Redis (ключ `hex:<map>:<q>:<r>`).
  - Использовать Express middleware для проверки токена перед подключением к Colyseus.
  - Логировать подключение: "Игрок <username> подключился к комнате <room_id>".
- **Детали**:
  - Новые комнаты создаются автоматически.
  - Пока без сложной логики — только подключение.
- **Результат**: Игроки подключаются к гексу через Express, при переполнении создается новая комната.

#### 6. Тестирование и документация
- **Описание**: Обеспечить тестирование и документирование кода.
- **Подзадачи**:
  - Написать Jest тесты для аутентификации (вход, проверка токена, создание профиля).
  - Написать тесты для Redis (сохранение, загрузка, выгрузка сессии).
  - Документировать код с помощью JSDoc (функции входа, middleware, работа с Redis).
- **Детали**:
  - Тесты покрывают базовые сценарии (вход, бан, восстановление сессии).
  - JSDoc для каждой функции с описанием параметров и возвращаемых значений.
- **Результат**: Код протестирован и задокументирован.

---